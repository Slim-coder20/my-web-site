{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 88, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Slim%20Backup/Projets/Dossier%20Professionel%20Studi%202026%20/slim_site_internet/my-web-site/lib/prisma.ts"],"sourcesContent":["import { PrismaClient } from \"@prisma/client\";\n\nconst globalForPrisma = globalThis as unknown as {\n  prisma: PrismaClient | undefined;\n};\n\nexport const prisma =\n  globalForPrisma.prisma ??\n  new PrismaClient({\n    log: process.env.NODE_ENV === \"development\" ? [\"query\", \"error\", \"warn\"] : [\"error\"],\n  });\n\nif (process.env.NODE_ENV !== \"production\") globalForPrisma.prisma = prisma;\n\n"],"names":[],"mappings":";;;;AAAA;;AAEA,MAAM,kBAAkB;AAIjB,MAAM,SACX,gBAAgB,MAAM,IACtB,IAAI,6IAAY,CAAC;IACf,KAAK,uCAAyC;QAAC;QAAS;QAAS;KAAO,GAAG;AAC7E;AAEF,wCAA2C,gBAAgB,MAAM,GAAG"}},
    {"offset": {"line": 107, "column": 0}, "map": {"version":3,"sources":["file:///Volumes/Slim%20Backup/Projets/Dossier%20Professionel%20Studi%202026%20/slim_site_internet/my-web-site/app/api/checkout/route.ts"],"sourcesContent":["/**\n * Route API : POST /api/checkout\n * \n * Cette route gère la création d'une session de paiement Stripe Checkout.\n * \n * FLUX DE TRAVAIL :\n * 1. Reçoit productId et email depuis le formulaire de checkout\n * 2. Récupère le produit depuis la base de données MySQL via Prisma\n * 3. Crée une Order en statut \"pending\" dans la table Order\n * 4. Crée un OrderItem associé dans la table OrderItem\n * 5. Crée une session Stripe Checkout avec les détails du produit\n * 6. Met à jour l'Order avec le stripeSessionId pour pouvoir la retrouver plus tard\n * 7. Retourne l'URL de la session Stripe pour rediriger l'utilisateur\n * \n * IMPORTANT : L'Order est créée AVANT le paiement pour pouvoir la tracker.\n * Le statut passera à \"paid\" via le webhook Stripe après paiement réussi.\n */\n\nimport { NextRequest, NextResponse } from \"next/server\";\nimport Stripe from \"stripe\";\nimport { prisma } from \"@/lib/prisma\";\n\n// Initialisation du client Stripe avec la clé secrète\nconst stripe = new Stripe(process.env.STRIPE_SECRET_KEY!, {\n  apiVersion: \"2025-10-29.clover\",\n});\n\nexport async function POST(request: NextRequest) {\n  try {\n    // Récupération des données du body (productId et email)\n    const body = await request.json();\n    const { productId, email } = body;\n\n    // Validation des données requises\n    if (!productId || !email) {\n      return NextResponse.json(\n        { error: \"Product ID and email are required\" },\n        { status: 400 }\n      );\n    }\n\n    // Récupération du produit depuis la base de données MySQL\n    const product = await prisma.product.findUnique({\n      where: { id: parseInt(productId) },\n    });\n\n    if (!product) {\n      return NextResponse.json({ error: \"Product not found\" }, { status: 404 });\n    }\n\n    /**\n     * ÉTAPE 1 : Création de l'Order en base de données\n     * \n     * On crée l'Order AVANT le paiement pour pouvoir la tracker.\n     * Statut initial : \"pending\" (en attente de paiement)\n     * Le statut sera mis à jour à \"paid\" par le webhook Stripe après paiement réussi.\n     */\n    const order = await prisma.order.create({\n      data: {\n        email, // Email du client pour la confirmation\n        amountTotal: product.priceCents, // Montant total en centimes\n        status: \"pending\", // Statut initial : en attente de paiement\n        items: {\n          // Création simultanée de l'OrderItem associé\n          create: {\n            productId: product.id,\n            quantity: 1, // Pour l'instant, on ne gère que les commandes d'un seul album\n            unitPrice: product.priceCents, // Prix unitaire en centimes\n          },\n        },\n      },\n    });\n\n    /**\n     * ÉTAPE 2 : Création de la session Stripe Checkout\n     * \n     * Stripe Checkout est une page de paiement hébergée par Stripe.\n     * On configure :\n     * - Les items à payer (l'album avec son prix)\n     * - Les URLs de redirection (succès/annulation)\n     * - L'email du client\n     * - Les métadonnées pour retrouver l'Order (orderId)\n     */\n    const session = await stripe.checkout.sessions.create({\n      payment_method_types: [\"card\"], // Paiement par carte bancaire uniquement\n      line_items: [\n        {\n          price_data: {\n            currency: \"eur\", // Devise : Euro\n            product_data: {\n              name: product.title, // Nom de l'album\n              description: product.description || undefined, // Description optionnelle\n              images: product.coverUrl ? [product.coverUrl] : undefined, // Image de la pochette\n            },\n            unit_amount: product.priceCents, // Prix en centimes (ex: 1500 = 15,00€)\n          },\n          quantity: 1, // Quantité : 1 album\n        },\n      ],\n      mode: \"payment\", // Mode paiement unique (pas d'abonnement)\n      success_url: `${\n        process.env.NEXT_PUBLIC_SITE_URL || \"http://localhost:3000\"\n      }/discographie?success=true&session_id={CHECKOUT_SESSION_ID}`, // URL de redirection après paiement réussi avec session_id\n      cancel_url: `${\n        process.env.NEXT_PUBLIC_SITE_URL || \"http://localhost:3000\"\n      }/discographie?canceled=true`, // URL de redirection si annulation\n      customer_email: email, // Email du client (pré-rempli dans le formulaire Stripe)\n      metadata: {\n        orderId: order.id.toString(), // ID de l'Order pour pouvoir la retrouver\n      },\n    });\n\n    /**\n     * ÉTAPE 3 : Mise à jour de l'Order avec le stripeSessionId\n     * \n     * On stocke le stripeSessionId dans l'Order pour pouvoir :\n     * - Retrouver l'Order depuis le webhook Stripe\n     * - Vérifier le statut du paiement si besoin\n     */\n    await prisma.order.update({\n      where: { id: order.id },\n      data: { stripeSessionId: session.id },\n    });\n\n    // Retour de l'URL de la session Stripe pour rediriger l'utilisateur\n    return NextResponse.json({ sessionId: session.id, url: session.url });\n  } catch (error) {\n    console.error(\"Error creating checkout session:\", error);\n    return NextResponse.json(\n      { error: \"Failed to create checkout session\" },\n      { status: 500 }\n    );\n  }\n}\n"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;CAgBC;;;;AAED;AACA;AACA;;;;AAEA,sDAAsD;AACtD,MAAM,SAAS,IAAI,mKAAM,CAAC,QAAQ,GAAG,CAAC,iBAAiB,EAAG;IACxD,YAAY;AACd;AAEO,eAAe,KAAK,OAAoB;IAC7C,IAAI;QACF,wDAAwD;QACxD,MAAM,OAAO,MAAM,QAAQ,IAAI;QAC/B,MAAM,EAAE,SAAS,EAAE,KAAK,EAAE,GAAG;QAE7B,kCAAkC;QAClC,IAAI,CAAC,aAAa,CAAC,OAAO;YACxB,OAAO,gJAAY,CAAC,IAAI,CACtB;gBAAE,OAAO;YAAoC,GAC7C;gBAAE,QAAQ;YAAI;QAElB;QAEA,0DAA0D;QAC1D,MAAM,UAAU,MAAM,yHAAM,CAAC,OAAO,CAAC,UAAU,CAAC;YAC9C,OAAO;gBAAE,IAAI,SAAS;YAAW;QACnC;QAEA,IAAI,CAAC,SAAS;YACZ,OAAO,gJAAY,CAAC,IAAI,CAAC;gBAAE,OAAO;YAAoB,GAAG;gBAAE,QAAQ;YAAI;QACzE;QAEA;;;;;;KAMC,GACD,MAAM,QAAQ,MAAM,yHAAM,CAAC,KAAK,CAAC,MAAM,CAAC;YACtC,MAAM;gBACJ;gBACA,aAAa,QAAQ,UAAU;gBAC/B,QAAQ;gBACR,OAAO;oBACL,6CAA6C;oBAC7C,QAAQ;wBACN,WAAW,QAAQ,EAAE;wBACrB,UAAU;wBACV,WAAW,QAAQ,UAAU;oBAC/B;gBACF;YACF;QACF;QAEA;;;;;;;;;KASC,GACD,MAAM,UAAU,MAAM,OAAO,QAAQ,CAAC,QAAQ,CAAC,MAAM,CAAC;YACpD,sBAAsB;gBAAC;aAAO;YAC9B,YAAY;gBACV;oBACE,YAAY;wBACV,UAAU;wBACV,cAAc;4BACZ,MAAM,QAAQ,KAAK;4BACnB,aAAa,QAAQ,WAAW,IAAI;4BACpC,QAAQ,QAAQ,QAAQ,GAAG;gCAAC,QAAQ,QAAQ;6BAAC,GAAG;wBAClD;wBACA,aAAa,QAAQ,UAAU;oBACjC;oBACA,UAAU;gBACZ;aACD;YACD,MAAM;YACN,aAAa,GACX,6DAAoC,wBACrC,2DAA2D,CAAC;YAC7D,YAAY,GACV,6DAAoC,wBACrC,2BAA2B,CAAC;YAC7B,gBAAgB;YAChB,UAAU;gBACR,SAAS,MAAM,EAAE,CAAC,QAAQ;YAC5B;QACF;QAEA;;;;;;KAMC,GACD,MAAM,yHAAM,CAAC,KAAK,CAAC,MAAM,CAAC;YACxB,OAAO;gBAAE,IAAI,MAAM,EAAE;YAAC;YACtB,MAAM;gBAAE,iBAAiB,QAAQ,EAAE;YAAC;QACtC;QAEA,oEAAoE;QACpE,OAAO,gJAAY,CAAC,IAAI,CAAC;YAAE,WAAW,QAAQ,EAAE;YAAE,KAAK,QAAQ,GAAG;QAAC;IACrE,EAAE,OAAO,OAAO;QACd,QAAQ,KAAK,CAAC,oCAAoC;QAClD,OAAO,gJAAY,CAAC,IAAI,CACtB;YAAE,OAAO;QAAoC,GAC7C;YAAE,QAAQ;QAAI;IAElB;AACF"}}]
}